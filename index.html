<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="RefleX : Reflection-based Type Modeling for DDS-XTypes">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>RefleX</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/rticommunity/rticonnextdds-reflex">View on GitHub</a>

          <h1 id="project_title">RefleX</h1>
          <h2 id="project_tagline">Reflection-based Type Modeling for DDS-XTypes</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/rticommunity/rticonnextdds-reflex/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/rticommunity/rticonnextdds-reflex/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h3>
<a id="welcome-to" class="anchor" href="#welcome-to" aria-hidden="true"><span class="octicon octicon-link"></span></a>Welcome to</h3>

<p><img src="https://raw.githubusercontent.com/rticommunity/rticonnextdds-reflex/master/www/reflex-log-small.png" alt="RefleX Logo"></p>

<p>RefleX is a short for Reflection for DDS-XTypes. The main objective of this library is to create DDS-XTypes compliant type representations directly from native C++ types. RefleX is declarative–i.e., it is not a reflection API. There is no separate code generation step involved (other than compilation). The RefleX library will take your application-level datatypes in C++ and will happily map them to equivalent DDS topic types.</p>

<h3>
<a id="example" class="anchor" href="#example" aria-hidden="true"><span class="octicon octicon-link"></span></a>Example</h3>

<p>Consider the following simple <code>ShapeType</code> class.</p>

<div class="highlight highlight-cpp"><pre>    <span class="pl-st">class</span> <span class="pl-en">ShapeType</span> {
      std::string color_;
      <span class="pl-st">int</span> x_, y_, shapesize_;

    <span class="pl-s">public:</span>
      <span class="pl-en">ShapeType</span>() {}
      <span class="pl-en">ShapeType</span>(<span class="pl-s">const</span> std::string &amp; color,
                <span class="pl-st">int</span> x, <span class="pl-st">int</span> y, <span class="pl-st">int</span> shapesize)
       : color_(color), x_(x), y_(y),
          <span class="pl-en">shapesize_</span>(shapesize)
      {}

      std::string &amp; <span class="pl-en">color</span>() { <span class="pl-k">return</span> color_;     }
      <span class="pl-st">int</span> &amp; <span class="pl-en">x</span>()             { <span class="pl-k">return</span> x_;         }
      <span class="pl-st">int</span> &amp; <span class="pl-en">y</span>()             { <span class="pl-k">return</span> y_;         }
      <span class="pl-st">int</span> &amp; <span class="pl-en">shapesize</span>()     { <span class="pl-k">return</span> shapesize_; }

      <span class="pl-s">const</span> std::string &amp; <span class="pl-en">color</span>() <span class="pl-s">const</span> { <span class="pl-k">return</span> color_;     }
      <span class="pl-s">const</span> <span class="pl-st">int</span> &amp; <span class="pl-en">x</span>()             <span class="pl-s">const</span> { <span class="pl-k">return</span> x_;         }
      <span class="pl-s">const</span> <span class="pl-st">int</span> &amp; <span class="pl-en">y</span>()             <span class="pl-s">const</span> { <span class="pl-k">return</span> y_;         }
      <span class="pl-s">const</span> <span class="pl-st">int</span> &amp; <span class="pl-en">shapesize</span>()     <span class="pl-s">const</span> { <span class="pl-k">return</span> shapesize_; }
    };</pre></div>

<p>To send and receive instances of this class using DDS, simply add the <code>RTI_ADAPT_STRUCT</code> macro below. Note that the <code>color</code> is the key.</p>

<div class="highlight highlight-cpp"><pre>#<span class="pl-k">include</span> <span class="pl-s1"><span class="pl-pds">"</span>reflex.h<span class="pl-pds">"</span></span>

<span class="pl-en">RTI_ADAPT_STRUCT</span>(
  ShapeType,
  (std::string, color(), RTI_KEY)
  (<span class="pl-st">int</span>,             x())
  (<span class="pl-st">int</span>,             y())
  (<span class="pl-st">int</span>,     shapesize()))</pre></div>

<p>The <code>ShapeType</code> class and its objects can now be used with RTI Connext DDS. Here's the <code>main</code> program that writes a <code>ShapeType</code> objects. <code>GenericDataWriter</code> is an thin shim layer to simplify using DDS DataWriter with RefleX. It is not mandatory, however. </p>

<div class="highlight highlight-cpp"><pre><span class="pl-st">int</span> <span class="pl-en">main</span> (<span class="pl-st">void</span>)
{
  <span class="pl-c">// ... setup participant</span>

  reflex::GenericDataWriter&lt;ShapeType&gt;
      <span class="pl-s3">writer</span>(participant, <span class="pl-s1"><span class="pl-pds">"</span>Square<span class="pl-pds">"</span></span>);
  ShapeType <span class="pl-vo">shape</span>(<span class="pl-s1"><span class="pl-pds">"</span>BLUE<span class="pl-pds">"</span></span>, <span class="pl-c1">10</span>, <span class="pl-c1">20</span>, <span class="pl-c1">30</span>);
  writer.<span class="pl-s3">write</span>(shape);
}</pre></div>

<p>RefleX maps the ShapeType class to the following ShapeType IDL, which is interoperable with Shapes Demo.</p>

<div class="highlight highlight-cpp"><pre><span class="pl-st">struct</span> <span class="pl-en">ShapeType</span>
{
    string&lt;<span class="pl-c1">128</span>&gt; color; <span class="pl-c">//@key</span>
    <span class="pl-st">long</span> x;
    <span class="pl-st">long</span> y;
    <span class="pl-st">long</span> shapesize;
};<span class="pl-c">//@Extensibility EXTENSIBLE_EXTENSIBILITY</span></pre></div>

<h3>
<a id="license" class="anchor" href="#license" aria-hidden="true"><span class="octicon octicon-link"></span></a>License</h3>

<p>(c) 2005-2014 Copyright, Real-Time Innovations, Inc.  All rights reserved.<br>
RTI grants Licensee a license to use, modify, compile, and create derivative works 
of the Software.  Licensee has the right to distribute object form only for use with RTI 
products.  The Software is provided “as is”, with no warranty of any type, including 
any warranty for fitness for any purpose. RTI is under no obligation to maintain or 
support the Software.  RTI shall not be liable for any incidental or consequential 
damages arising out of the use or inability to use the software.</p>

<h3>
<a id="contact" class="anchor" href="#contact" aria-hidden="true"><span class="octicon octicon-link"></span></a>Contact</h3>

<p>Sumant Tambe (sumant at RTI d0t com)</p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">RefleX maintained by <a href="https://github.com/rticommunity">rticommunity</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
