<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="RefleX : Reflection-based Type Modeling for DDS-XTypes">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>RefleX</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/rticommunity/rticonnextdds-reflex">View on GitHub</a>

          <h1 id="project_title">RefleX</h1>
          <h2 id="project_tagline">Reflection-based Type Modeling for DDS-XTypes</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/rticommunity/rticonnextdds-reflex/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/rticommunity/rticonnextdds-reflex/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h3>
<a id="welcome-to" class="anchor" href="#welcome-to" aria-hidden="true"><span class="octicon octicon-link"></span></a>Welcome to</h3>

<p><img src="images/reflex-log-small.png" alt="RefleX Logo"></p>

<p>RefleX is a short for <strong>Reflection for DDS-XTypes</strong>. The main objective of this library is to create DDS-XTypes compliant types and data directly from native C++ types. RefleX is declarative–i.e., it is not a reflection API. There is no separate code generation step involved (other than compilation). The RefleX library will take your application-level datatypes in C++ and will happily map them to equivalent DDS topic types.</p>

<h3>
<a id="example" class="anchor" href="#example" aria-hidden="true"><span class="octicon octicon-link"></span></a>Example</h3>

<hr>

<p>Consider the following simple <code>ShapeType</code> class.</p>

<div class="highlight highlight-cpp"><pre><span class="pl-st">class</span> <span class="pl-en">ShapeType</span> 
{
  std::string color_;
  <span class="pl-st">int</span> x_, y_, shapesize_;

<span class="pl-s">public:</span>
  <span class="pl-en">ShapeType</span>() {}
  <span class="pl-en">ShapeType</span>(<span class="pl-s">const</span> std::string &amp; color,
            <span class="pl-st">int</span> x, <span class="pl-st">int</span> y, <span class="pl-st">int</span> shapesize)
    : color_(color), x_(x), y_(y),
      <span class="pl-en">shapesize_</span>(shapesize)
  {}

  std::string &amp; <span class="pl-en">color</span>() { <span class="pl-k">return</span> color_;     }
  <span class="pl-st">int</span> &amp; <span class="pl-en">x</span>()             { <span class="pl-k">return</span> x_;         }
  <span class="pl-st">int</span> &amp; <span class="pl-en">y</span>()             { <span class="pl-k">return</span> y_;         }
  <span class="pl-st">int</span> &amp; <span class="pl-en">shapesize</span>()     { <span class="pl-k">return</span> shapesize_; }

  <span class="pl-s">const</span> std::string &amp; <span class="pl-en">color</span>() <span class="pl-s">const</span> { <span class="pl-k">return</span> color_;     }
  <span class="pl-s">const</span> <span class="pl-st">int</span> &amp; <span class="pl-en">x</span>()             <span class="pl-s">const</span> { <span class="pl-k">return</span> x_;         }
  <span class="pl-s">const</span> <span class="pl-st">int</span> &amp; <span class="pl-en">y</span>()             <span class="pl-s">const</span> { <span class="pl-k">return</span> y_;         }
  <span class="pl-s">const</span> <span class="pl-st">int</span> &amp; <span class="pl-en">shapesize</span>()     <span class="pl-s">const</span> { <span class="pl-k">return</span> shapesize_; }
};</pre></div>

<p>To send and receive instances of this class using DDS, simply add the <code>RTI_ADAPT_STRUCT</code> macro below. Note that <code>color</code> is the key.</p>

<div class="highlight highlight-cpp"><pre>#<span class="pl-k">include</span> <span class="pl-s1"><span class="pl-pds">"</span>reflex.h<span class="pl-pds">"</span></span>

<span class="pl-en">RTI_ADAPT_STRUCT</span>(
  ShapeType,
  (std::string, color(), RTI_KEY)
  (<span class="pl-st">int</span>,             x())
  (<span class="pl-st">int</span>,             y())
  (<span class="pl-st">int</span>,     shapesize()))</pre></div>

<p>The <code>ShapeType</code> class and its objects can now be used with RTI Connext DDS. Here's the <code>main</code> program that writes a <code>ShapeType</code> objects. <code>GenericDataWriter</code> is an thin shim layer to simplify using DDS DataWriter with RefleX. It is not mandatory, however. </p>

<div class="highlight highlight-cpp"><pre><span class="pl-st">int</span> <span class="pl-en">main</span> (<span class="pl-st">void</span>)
{
  <span class="pl-c">// ... setup participant</span>

  reflex::GenericDataWriter&lt;ShapeType&gt;
      <span class="pl-s3">writer</span>(participant, <span class="pl-s1"><span class="pl-pds">"</span>Square<span class="pl-pds">"</span></span>);
  ShapeType <span class="pl-vo">shape</span>(<span class="pl-s1"><span class="pl-pds">"</span>BLUE<span class="pl-pds">"</span></span>, <span class="pl-c1">10</span>, <span class="pl-c1">20</span>, <span class="pl-c1">30</span>);
  writer.<span class="pl-s3">write</span>(shape);
}</pre></div>

<p>RefleX maps the <code>ShapeType</code> class to the following <code>ShapeType</code> IDL, which is interoperable with the Shapes Demo.</p>

<div class="highlight highlight-cpp"><pre><span class="pl-st">struct</span> <span class="pl-en">ShapeType</span>
{
    string&lt;<span class="pl-c1">128</span>&gt; color; <span class="pl-c">//@key</span>
    <span class="pl-st">long</span> x;
    <span class="pl-st">long</span> y;
    <span class="pl-st">long</span> shapesize;
};<span class="pl-c">//@Extensibility EXTENSIBLE_EXTENSIBILITY</span></pre></div>

<h3>
<a id="what-powers-reflex" class="anchor" href="#what-powers-reflex" aria-hidden="true"><span class="octicon octicon-link"></span></a>What powers RefleX?</h3>

<hr>

<p>The Reflex library uses powerful C++ meta-programming (templates and the preprocessor) machinery to iterate over the members of the user-defined type and synthesizes equivalent <code>TypeObject</code> representation for the type and <code>DynamicData</code> representation for the state. <code>RTI_ADAPT_STRUCT</code> macro acts as a substitute for reflection in C++. It is not the kind of reflection in the Java/C# world. It is a macro, which opens the guts of the specified type to the RefleX library (take a <a href="https://github.com/rticommunity/rticonnextdds-reflex/blob/master/test/shape_type_adapt.h">look</a>). The key difference is that the process of reflection happens at compile-time. As a consequence, there is no run-time performance penalty for using reflection. The resulting on-the-wire type description is fully compatible with an equivalent type described in IDL. Needless to say, they interoperate.</p>

<h3>
<a id="c-types-supported-by-reflex" class="anchor" href="#c-types-supported-by-reflex" aria-hidden="true"><span class="octicon octicon-link"></span></a>C++ Types Supported by RefleX</h3>

<hr>

<ul>
<li>All fundamental types, arrays, multi-dimensional arrays, enumerations</li>
<li>Struct (with public members) (<a href="https://github.com/rticommunity/rticonnextdds-reflex/blob/master/test/many_members.h">example</a>)</li>
<li>Classes (with setter/getter) (<a href="https://github.com/rticommunity/rticonnextdds-reflex/blob/master/test/shape_type.h">example</a>)</li>
<li>Nested struct/classes (<a href="https://github.com/rticommunity/rticonnextdds-reflex/blob/master/test/darkart.h">example</a>)</li>
<li>Standard Template Library (STL) <code>string</code>, <code>vector</code>, <code>list</code>, <code>set</code>, <code>map</code>, <code>array</code>, <code>tuple</code>, <code>pair</code>, iterators, etc. </li>
<li>Raw pointer, smart pointers</li>
<li>Optional members (e.g., boost::optional)</li>
<li>User-defined/custom containers (e.g., those that expose STL-compatible iterators, boost.Iterators) (<a href="https://github.com/rticommunity/rticonnextdds-reflex/blob/master/test/osacbm/driver.cxx">example</a>)</li>
<li>Class inheritance (<a href="https://github.com/rticommunity/rticonnextdds-reflex/blob/master/test/shape_type.h">example</a>)</li>
<li>Most combinations of the above </li>
</ul>

<h3>
<a id="advantages-of-reflex" class="anchor" href="#advantages-of-reflex" aria-hidden="true"><span class="octicon octicon-link"></span></a>Advantages of RefleX</h3>

<hr>

<ol>
<li><p><strong>Native Types (IDL-free):</strong> IDL representation of DDS types is no longer necessary. Adapted C++ types declarations in the headers are sufficient. With RefleX, you are free to use C++ standard library types, such as STL containers, custom iterators, <code>shared_ptr</code>, <code>auto_ptr</code>, <code>unique_ptr</code>, etc. The RefleX library has a predefined mapping for each and you can also define your own mapping. </p></li>
<li><p><strong>Declarative Dynamic Data:</strong> <code>DynamicData</code> and <code>TypeCode</code> objects can be created declaratively as opposed to procedurally, which quickly gets laborious and repetitive as the complexity of the type increases. Many times, types are known statically but no code generation support is available (e.g., RTI Routing Service adapters). With RefleX, creating a TypeCode and populating a DynamicData object is never more than one line of code!</p></li>
<li><p><strong>Third-party code generators:</strong> Classes generated by third-party code generation tools can be mapped to DDS topic types. The key is that RefleX works directly off of C++ types. The generated types may use a wide variety of types (e.g., boost containers, custom iterators, etc.). RefleX provides a way to map such types directly to a DDS. For example, with RefleX the types generated by a third-party XSD to C++ compiler can be mapped to DDS by adding an <code>RTI_ADAPT_STRUCT</code> macro for each generated type. See an <a href="https://github.com/rticommunity/rticonnextdds-reflex/blob/master/test/osacbm/driver.cxx">example</a> of mapping <a href="https://github.com/rticommunity/rticonnextdds-reflex/tree/master/test/osacbm/mimosa-osa-cbm-v03-3-1/V3.3.1/02-XSD">OSA-CBM XSD</a> to DDS using the <a href="http://www.codesynthesis.com/products/xsd/">Code Synthesis</a> open-source code generator. </p></li>
<li><p><strong>Glue code:</strong> Glue code must often be written because wire-level types may not always match with the application-level types. RefleX allows direct use of application-level types with DDS. Glue code is nearly eliminated.</p></li>
<li><p><strong>Performance:</strong> Users of complex XML vocabularies (e.g., XSD) often serialize data to plain-text XML before writing it out to DDS. Such an approach incurs significant performance penalty as data is serialized twice. RefleX does only one serialization as the underlying DynamicData representation is already serialized. </p></li>
</ol>

<h3>
<a id="download-and-build" class="anchor" href="#download-and-build" aria-hidden="true"><span class="octicon octicon-link"></span></a>Download and Build</h3>

<hr>

<h4>
<a id="linux" class="anchor" href="#linux" aria-hidden="true"><span class="octicon octicon-link"></span></a>Linux</h4>

<ol>
<li>Use gcc 4.8, clang 3.3 or better</li>
<li>export REFLEXHOME, BOOSTHOME (1.46+) and NDDSHOME (5.0.0+)</li>
<li>export ARCH=i86Linux2.6gcc4.4.5, for example. See make/Makefile* for details</li>
<li>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$NDDSHOME/lib/$ARCH:$REFLEXHOME/objs/$ARCH</li>
<li>Example: make -f make/Makefile.i86Linux-gcc CXX=g++48 (g++48 must be in your $PATH) </li>
</ol>

<h4>
<a id="visual-studio-2013-build" class="anchor" href="#visual-studio-2013-build" aria-hidden="true"><span class="octicon octicon-link"></span></a>Visual Studio 2013 Build</h4>

<ol>
<li>Set REFLEXHOME, BOOSTHOME (1.46+), and NDDSHOME (5.1.0+)</li>
<li>Set PATH=%PATH%;%REFLEXHOME%\objs\i86Win32VS2013;%NDDSHOME%\lib\i86Win32VS2012</li>
<li>(Optional) Run %NDDSHOME%\scripts\rtiddsgen -language C++ -namespace -d test idl\complex.idl</li>
<li>Open win32\reflex-vs2013.sln using Visual Studio and build.</li>
</ol>

<h3>
<a id="more-reading" class="anchor" href="#more-reading" aria-hidden="true"><span class="octicon octicon-link"></span></a>More reading</h3>

<hr>

<ul>
<li><a href="http://blogs.rti.com/2014/03/22/rti-reflex-reflection-based-type-modeling-for-dds-topics/">RefleX announcement</a></li>
<li><a href="http://community.rti.com/paper/c-template-library-data-centric-type-modeling-dds-xtypes">RefleX whitepaper</a></li>
<li><a href="http://www.slideshare.net/SumantTambe/overloading-in-overdrive-a-generic-datacentric-library-for">Overloading in Overdrive presentation</a></li>
</ul>

<h3>
<a id="license" class="anchor" href="#license" aria-hidden="true"><span class="octicon octicon-link"></span></a>License</h3>

<hr>

<p>(c) 2005-2014 Copyright, Real-Time Innovations, Inc.  All rights reserved.<br>
RTI grants Licensee a license to use, modify, compile, and create derivative works 
of the Software.  Licensee has the right to distribute object form only for use with RTI 
products.  The Software is provided “as is”, with no warranty of any type, including 
any warranty for fitness for any purpose. RTI is under no obligation to maintain or 
support the Software.  RTI shall not be liable for any incidental or consequential 
damages arising out of the use or inability to use the software.</p>

<h3>
<a id="contact" class="anchor" href="#contact" aria-hidden="true"><span class="octicon octicon-link"></span></a>Contact</h3>

<hr>

<p>Sumant Tambe (sumant at RTI d0t com)</p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">RefleX maintained by <a href="https://github.com/rticommunity">rticommunity</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
