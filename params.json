{"name":"RefleX","tagline":"Building DDS Applications without IDL","body":"![RTI logo](images/rti-logounit.png)\r\n\r\n![RefleX Logo](images/reflex-logo-small.png)\r\n\r\nRefleX is short for **Reflection for DDS-XTypes**. The main objective of this library is to create DDS-XTypes compliant types and data directly from native C++ types. RefleX is declarative–i.e., it is not a reflection API. There is no separate code generation step involved (other than compilation). The RefleX library will take your application-level datatypes in C++ and will happily map them to equivalent DDS topic types.\r\n\r\n### Example\r\nConsider the following simple `ShapeType` class.\r\n```cpp\r\nclass ShapeType \r\n{\r\n  std::string color_;\r\n  int x_, y_, shapesize_;\r\n\r\npublic:\r\n  ShapeType() {}\r\n  ShapeType(const std::string & color,\r\n            int x, int y, int shapesize)\r\n    : color_(color), x_(x), y_(y),\r\n      shapesize_(shapesize)\r\n  {}\r\n    \r\n  std::string & color() { return color_;     }\r\n  int & x()             { return x_;         }\r\n  int & y()             { return y_;         }\r\n  int & shapesize()     { return shapesize_; }\r\n      \r\n  const std::string & color() const { return color_;     }\r\n  const int & x()             const { return x_;         }\r\n  const int & y()             const { return y_;         }\r\n  const int & shapesize()     const { return shapesize_; }\r\n};\r\n```\r\nTo send and receive instances of this class using DDS, simply add the `REFLEX_ADAPT_STRUCT` macro below. Note that `color` is the key.\r\n```cpp\r\n#include \"reflex.h\"\r\n\r\nREFLEX_ADAPT_STRUCT(\r\n  ShapeType,\r\n  (std::string, color(), REFLEX_KEY)\r\n  (int,             x())\r\n  (int,             y())\r\n  (int,     shapesize()))\r\n```\r\nThe `ShapeType` class and its objects can now be used with RTI Connext DDS. Here's the `main` program that writes a `ShapeType` objects. `GenericDataWriter` is an thin shim layer to simplify using DDS DataWriter with RefleX. It is not mandatory, however. \r\n```cpp\r\nint main (void)\r\n{\r\n  // ... setup participant\r\n\r\n  reflex::GenericDataWriter<ShapeType>\r\n      writer(participant, \"Square\");\r\n  ShapeType shape(\"BLUE\", 10, 20, 30);\r\n  writer.write(shape);\r\n}\r\n```\r\nRefleX maps the `ShapeType` class to the following `ShapeType` IDL, which is inter-operable with the Shapes Demo.\r\n```cpp\r\nstruct ShapeType\r\n{\r\n    string<128> color; //@key\r\n    long x;\r\n    long y;\r\n    long shapesize;\r\n};//@Extensibility EXTENSIBLE_EXTENSIBILITY\r\n```\r\n\r\n### Why RefleX?\r\n1. **Use Native C++ Types with DDS (IDL-free):** IDL representation of DDS types is no longer necessary. Adapted C++ types declarations in the headers are sufficient. With RefleX, you are free to use C++ standard library types, such as STL containers, custom iterators, `shared_ptr`, `auto_ptr`, `unique_ptr`, etc. The RefleX library has a predefined mapping for each and you can also define your own. \r\n\r\n2. **Use Declarative Dynamic Data:** `DynamicData` and `TypeCode` objects can be created declaratively as opposed to procedurally, which quickly gets laborious and repetitive as the complexity of the type increases. RefleX is based on the principle of _Don't Repeat Yourself_ (DRY). RefleX _completely_ eliminates the repetitive work in using the `DynamicData` API. Many times, types are known statically but no code generation support is available (e.g., RTI Routing Service adapters). With RefleX, creating a `TypeCode` and populating a corresponding `DynamicData` object is never more than one line of code!\r\n\r\n3. **Use Third-party Code Generators:** Classes generated by third-party code generation tools can be mapped to DDS topic types. The key is that RefleX works directly off of C++ types. The generated types may use a wide variety of types (e.g., boost containers, custom iterators, etc.). RefleX provides a way to map such types directly to a DDS. For example, with RefleX the types generated by a third-party XSD to C++ compiler can be mapped to DDS by adding an `RTI_ADAPT_STRUCT` macro for each generated type. See an [example](https://github.com/rticommunity/rticonnextdds-reflex/blob/master/test/osacbm/driver.cxx) of mapping [OSA-CBM XSD](https://github.com/rticommunity/rticonnextdds-reflex/tree/master/test/osacbm/mimosa-osa-cbm-v03-3-1/V3.3.1/02-XSD) to DDS using the [Code Synthesis](http://www.codesynthesis.com/products/xsd/) open-source code generator. \r\n\r\n4. **Improve Performance:** Users of complex XML vocabularies (e.g., XSD) often serialize data to plain-text XML before writing it out to DDS. Such an approach incurs significant performance penalty as data is serialized twice. RefleX does only one serialization as the underlying DynamicData representation is already serialized. \r\n\r\n5. **Avoid Glue code:** Glue code must often be written because wire-level types may not always match with the application-level types. RefleX allows direct use of application-level types with DDS. Glue code is nearly eliminated. It's all about avoiding repeating yourself.\r\n\r\n### What powers RefleX?\r\nThe Reflex library uses powerful C++ meta-programming (templates and the preprocessor) machinery to iterate over the members of the user-defined type and synthesizes equivalent `TypeObject` representation for the type and `DynamicData` representation for the state. `RTI_ADAPT_STRUCT` macro acts as a substitute for reflection in C++. The macro uses Boost Fusion internally. It is not the kind of reflection in the Java/C# world. It is a macro, which opens the guts of the specified type to the RefleX library (take a [look](https://github.com/rticommunity/rticonnextdds-reflex/blob/master/test/shape_type_adapt.h)). The key difference is that the process of reflection happens at compile-time. As a consequence, there is no run-time performance penalty for using reflection. The resulting on-the-wire type description is fully compatible with an equivalent type described in IDL. Needless to say, they interoperate.\r\n\r\n### Architecture\r\nRefleX is based on a simple layered architecture. DDS applications based on the classic C++ DDS API and the new C++ DDS PSM can make use of RefleX. \r\n\r\n![Architecture](images/architecture.png)\r\n\r\n### Native C++ Types Supported by RefleX\r\n* All fundamental types, arrays, multi-dimensional arrays, enumerations\r\n* Struct (with public members) ([example](https://github.com/rticommunity/rticonnextdds-reflex/blob/master/test/many_members.h))\r\n* Classes (with setter/getter) ([example](https://github.com/rticommunity/rticonnextdds-reflex/blob/master/test/shape_type.h))\r\n* Nested struct/classes ([example](https://github.com/rticommunity/rticonnextdds-reflex/blob/master/test/darkart.h))\r\n* Standard Template Library (STL) `string`, `vector`, `list`, `set`, `map`, `array`, `tuple`, `pair`, iterators, etc. \r\n* Raw pointer, smart pointers\r\n* Optional members (e.g., boost::optional)\r\n* User-defined/custom containers (e.g., those that expose STL-compatible iterators, boost.Iterators) ([example](https://github.com/rticommunity/rticonnextdds-reflex/blob/master/test/osacbm/driver.cxx))\r\n* Class inheritance ([example](https://github.com/rticommunity/rticonnextdds-reflex/blob/master/test/shape_type.h))\r\n* Most combinations of the above \r\n\r\n### Download and Build\r\n#### Linux \r\n1. Recommended compilers: g++ 4.8, clang 3.3 or better\r\n2. export REFLEXHOME, BOOSTHOME (1.46+) and NDDSHOME (5.0.0+)\r\n3. export ARCH=i86Linux2.6gcc4.8.2, for example.\r\n4. See make/Makefile* for details\r\n5. export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$NDDSHOME/lib/$ARCH:$REFLEXHOME/objs/$ARCH\r\n6. Build:               make -f make/Makefile.i86Linux-gcc CXX=g++48 (g++48 must be in your $PATH)\r\n7. Build tests:         make/Makefile.i86Linux-gcc test\r\n8. Build perf_test:     make/Makefile.i86Linux-gcc perf_test\r\n9. Build property_test: make/Makefile.i86Linux-gcc prop_test CXX=g++5 CXXSTD=c++14 RANDOM=$RANDOM\r\n\r\n### Windows\r\n1. Use Visual Studio 2013\r\n2. Set REFLEXHOME, BOOSTHOME (1.46+), and NDDSHOME (5.1.0+)\r\n3. Set PATH=%PATH%;%REFLEXHOME%\\objs\\i86Win32VS2013;%NDDSHOME%\\lib\\i86Win32VS2012\r\n4. Run %NDDSHOME%\\scripts\\rtiddsgen -language C++ -namespace -d test idl\\complex.idl\r\n5. Open win32\\reflex-vs2013.sln\r\n\r\n### Documentation\r\nSee [RefleX documentation](docs/html/index.html) generated using Doxygen.\r\n\r\n### More reading\r\n* [RefleX announcement](http://blogs.rti.com/2014/03/22/rti-reflex-reflection-based-type-modeling-for-dds-topics/)\r\n* [RefleX whitepaper](http://community.rti.com/paper/c-template-library-data-centric-type-modeling-dds-xtypes)\r\n* [Overloading in Overdrive presentation](http://www.slideshare.net/SumantTambe/overloading-in-overdrive-a-generic-datacentric-library-for)\r\n\r\n### License\r\n(c) 2005-2014 Copyright, Real-Time Innovations, Inc.  All rights reserved.    \t                             \r\nRTI grants Licensee a license to use, modify, compile, and create derivative works \r\nof the Software.  Licensee has the right to distribute object form only for use with RTI \r\nproducts.  The Software is provided “as is”, with no warranty of any type, including \r\nany warranty for fitness for any purpose. RTI is under no obligation to maintain or \r\nsupport the Software.  RTI shall not be liable for any incidental or consequential \r\ndamages arising out of the use or inability to use the software.\r\n\r\n### Contact \r\nSumant Tambe (sumant at RTI d0t com)","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}